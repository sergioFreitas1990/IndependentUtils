<#@ template debug="true" language="C#" #>
<#@ output extension=".cs" #>
<#@ parameter type="System.String" name="AssemblyName" #>
<#@ parameter type="System.String" name="NamespaceName" #>
<#@ parameter type="System.Type" name="InterfaceType" #>
<#@ assembly name="$(ProjectDir)\bin\Debug\IndependentUtils.Configuration.dll" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Configuration" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Configuration" #>
<#
if (AssemblyName == null || NamespaceName == null || InterfaceType == null)
{
#>
// Null parameters, code cannot be generated.
<#
}
else
{
	var model = IndependentUtils.Configuration.Generation.SectionGenerator.Generate(InterfaceType);
#>
//------------------------------------------------------------------------------ 
// <auto-generated> 
// This code was generated by a tool. 
// 
// Changes to this file may cause incorrect behavior and will be lost if 
// the code is regenerated. 
// </auto-generated> 
//------------------------------------------------------------------------------
namespace <#= model.Namespace #>
{
	/*
	 *
	 * Add the follwing line to your config sections:
	 *
	 * <section name="<#= model.ConfigSectionName #>" type="<#= NamespaceName #>.<#= model.ConfigSectionName #>, <#= AssemblyName #>, Culture=neutral, PublicKeyToken=null"/>
	 *
	 */
	[IndependentUtils.Configuration.Attributes.SectionName("<#= model.ConfigSectionName #>")]
<#
	var typeCount = 0;
	foreach(var currType in model.TypesToGenerate.OrderByDescending(t => t.IsConfigSectionType))
	{

		if(typeCount == 0)
		{
#>
	public partial class <#= currType.TypeName #> : System.Configuration.ConfigurationSection,
		<#= currType.InterfaceFullName #>
    {
<#		
		}
		else
		{
#>
	public partial class <#= currType.TypeName #> : System.Configuration.ConfigurationElement, 
		<#= currType.InterfaceFullName #>, 
		IndependentUtils.Configuration.IKeyd
	{
		private static readonly System.Func<<#= currType.TypeName #>, object> GetKeyFunc = <#= currType.GetKeyFunction #>;
		public virtual System.Object Key => GetKeyFunc(this);
<#
		}

		const string sperator = ", ";
		foreach(var currProperty in currType.ValueProperties) 
		{
			var propertyName = currProperty.PropertyName;
			var auxPropertyName = propertyName + "Aux";
			var configConstName = propertyName + "Tag";
			var propertyTypeName = currProperty.PropertyTypeName;
			var propertyOptions = currProperty.Options;

			var propertyOptionsString = !propertyOptions.Any()?
				System.String.Empty :
				sperator + System.String.Join(sperator, propertyOptions.Select(t => 
					string.Format("{0} = {1}", t.Key, ValueToString(t.Value))));
#>
		public const string <#= configConstName #> = "<#= currProperty.ConfigurationPropertyName #>";
		
		[System.Configuration.ConfigurationProperty(<#= configConstName #><#= propertyOptionsString #>)]
		protected virtual <#= currProperty.PropertyCastTypeName #> <#= auxPropertyName #> 
		{
			get
			{
				return (<#= currProperty.PropertyCastTypeName #>)this[<#= configConstName #>];
			}
			set
			{
				this[<#= configConstName #>] = value;
			}
		}

		public virtual <#= propertyTypeName #> <#= propertyName #> 
		{
			get
			{
				return <#= auxPropertyName #>;
			}
		}
<# 
		}
		foreach(var currProperty in currType.ListProperties) 
		{
			var propertyName = currProperty.PropertyName;
			var configConstName = propertyName + "Tag";

			// Generate the private Aux property that actually implements
			// The list.
			var auxPropertyName = propertyName + "Aux";
			var auxPropertyType = "IndependentUtils.Configuration.ConfigurationElementCollection<" + 
				currProperty.MembersTypeImplementationName + ">";

			var interfacePropertyName = propertyName;
			var interfacePropertyType = "System.Collections.Generic.IEnumerable<" + currProperty.MembersTypeFullName + ">";

			var propertyOptions = currProperty.Options;
			var propertyOptionsString = !propertyOptions.Any()?
				System.String.Empty :
				sperator + System.String.Join(sperator, propertyOptions.Select(t => 
					string.Format("{0} = {1}", t.Key, ValueToString(t.Value))));
#>
		
		public const string <#= configConstName #> = "<#= currProperty.ConfigurationPropertyName #>";
		
		[System.Configuration.ConfigurationProperty(<#= configConstName #><#= propertyOptionsString #>)]
        [System.Configuration.ConfigurationCollection(typeof(<#= auxPropertyType #>), AddItemName = "<#= currProperty.AddItemName #>")]
		protected virtual <#= auxPropertyType #> <#= auxPropertyName #>
		{
			get
			{
				return (<#= auxPropertyType #>)this[<#= configConstName #>];
			}
		}

		public virtual <#= interfacePropertyType #> <#= interfacePropertyName #>
		{
			get
			{
				return <#= auxPropertyName #>;
			}
		}
<#
		}
#>
	}

<# 
		typeCount++;
	} 
}
#>
}
<#+
    public string ValueToString(object value)
    {
		var typeOfValue = value.GetType();
		if (typeof(ConfigurationPropertyOptions).IsAssignableFrom(typeOfValue))
		{
			return string.Format("({0}) {1}", 
				typeof(ConfigurationPropertyOptions).FullName, 
				(int) value);
		}

		var stringValue = value.ToString();
		if (typeof(string).IsAssignableFrom(typeOfValue))
		{
			stringValue = string.Format("\"{0}\"", stringValue);
		}
		if (typeof(bool).IsAssignableFrom(typeOfValue))
		{
			stringValue = stringValue.ToLowerInvariant();
		}
		return stringValue;
    }
#>